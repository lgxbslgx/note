### 指令选择
- 指令选择: 将IR转换成目标机指令。IR操作-->目标处理器操作
- 指令调度: 为这些指令操作选择执行顺序
- 寄存器分配: 决定哪些值位于寄存器，哪些值位于内存

指令选择的复杂性在于处理器对同一计算提供许多不同的方法。


#### 简单的树遍历算法
- 基于模板的树遍历，生成目标代码。

#### 树模式匹配
- 不需显式遍历IR并判断每个操作，应该制定一些相关规则，由工具生成代码，将规则与IR进行匹配。
- IR和目标机指令都必须表示为树
- 树的前缀表示法，add r, c -> rk 表示为 +(r, c)
- 将AST映射到操作树，叫做平铺
- 重写规则: 产生式、成本、代码模板
- 平铺方案:
    - 1. 初始时，设置Label(n)集合为空，Label表示节点n的子树的所有规则的编号
    - 2.1 如果n的操作是一个2元运算符，遍历左子树、右子树（即以其作为参数，从1开始运行该算法）。
    - 2.2 对于每个规则，如果一个规则的左操作数在n的左节点的Label集合中，且右操作数在n的右节点的Label集合中,则把该规则放在节点n的Label集合中。
    - 3.1 如果n的操作是一个1元运算符，遍历左子树（即以其作为参数，从1开始运行该算法）。
    - 3.2 对于每个规则，如果一个规则的左操作数在n的左节点的Label集合中，则把该规则放在节点n的Label集合中。
    - 4 如果n没有操作数，则n是叶子节点，则把所有匹配n的操作的规则都放到Label(n)中。
- 在平铺方案中，加上成本的信息，则可以每次都保留最低成本匹配方案。动态规划思想。

#### 窥孔优化
- 一种局部的代码改进。输入: 汇编语言，输出汇编语言。
- 展开-简化-匹配
    - 展开程序，转换IR成底层IR（LLIR）。基于模板展开。
    - 简化: 通过小滑动窗口（局部优化）考察LLIR，以系统化的方式（前向替换、代数化简、常量表达式求值等）改进LLIR。
    - 匹配: 对着模式库比较简化过的LLIR，寻找以最佳方式捕获LLIR中所有效应的模式。然后生成汇编（LLIR -> ASM）。可以使用上文说的树模式匹配算法。
