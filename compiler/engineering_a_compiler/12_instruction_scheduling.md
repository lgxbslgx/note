### 指令调度（instruction scheduling）
- 一组操作（指令）的执行时间依赖其执行顺序。
- 对指令进行重新排序以有效利用处理器资源，称为指令调度。调度器的输入、输出都是汇编代码序列。
- 表调度: 贪婪启发式算法。
- 拖延、停顿: 处理器拖延一些操作，直到其操作数可用。互锁是发现过早发射指令的机制。
- 静态调度: 依赖编译器插入NOP来保证正确性。动态调动: 依赖互锁机制来保证正确性。
- 超标量处理器: 单周期内，向不同功能单元发射不同操作的处理器。
- 指令级并行性: 指令流中存在可以并发执行的操作。

#### 基础
- 依赖关系图D（前驱图）: 边表示程序块中值的流动。节点表示操作，里面有操作类型和延迟（完成需要的时间）。
- 叶子节点: 没有前驱节点的节点。注意和平常的叶子节点不同。
- 根节点: 没有后继节点的节点。注意和平常的根节点不同。
- 调度长度: L(S) = max 所有节点（ S(n) + delay(n) ），S(n)表示操作n开始执行的周期id，delay(n)表示操作n的执行时间。
- 关键路径: 依赖关系图中延迟最长的路径。
- 反相关（antidependence）: 如果操作x在操作y之前，且y定义了一个x使用的值，则操作x反相关于操作y。不能把操作y提到操作x前面。

#### 局部表调度
- 运行在一个基本块内，没有分支代码。
- 具体步骤:
    - 重命名以避免反相关。每个定义一个名字，有点像静态单赋值。
    - 建立依赖关系图。自底向上遍历块，每个操作作为一个节点，每个节点和其使用的值之间标上边（边有一个属性: 当前操作的延迟）。
    - 为每个操作指定优先级。其值一般是从当前节点到根节点之间，以延迟为权重计算长度时最长路径的长度。
    - 每次选择一个操作并调度它。
        - 1. 初始化时，cycle为1，ready为叶子节点，active为空。
        - 2. 每次都把active集合中已经完成的操作从active中删除，然后查看其后继节点，如果后继节点ready了，则放到ready集合中。
        - 3. 每次从ready集合中取出一个操作（可以按最长路径作为优先级来取操作），放在active集合中，表示该操作开始运行。
        - 4. 把cycle加1，继续2-4的操作。
- load操作的延迟是可变的，需要特殊处理。取与load无关的操作的平均值之和。
- 优先级除了最长路径之外，还可以有: 直接后继节点的数量、后代节点的数量、delay值等。
- 上面步骤指的是前向（forward）表调度。从根节点出发到叶子节点的调度是后向（backward）表调度。
- 关键操作在叶子节点上，则使用前向表调度。关键操作在根节点上，则使用后向表调度。

#### 区域性调度
- 拓展块EBB可以分成多个路径，每个路径的所有基础块 组成一个新的大的基础块。
- 补偿代码: 插入到基础块i中，用于抵消不包含i的代码路径上跨程序块的代码移动所带来副效应的代码。
- 路径调度: 每次对每个EBB路径组成的新基础块进行调度，并插入补偿代码。
- 跟踪调度: 每次都对整个CFG的最长无环路径进行调度，也要插入补偿代码。
- 通过复制，使得整个过程变成了一个EBB，跟踪调度变成了路径调动。

#### 高级主题
- 硬件流水线、软件流水线（software pipeline）
- 修改操作顺序以满足多个功能单元的协作，减少每次循环迭代的周期数。
- 循环核
- 模调度
- // TODO 未认真看
