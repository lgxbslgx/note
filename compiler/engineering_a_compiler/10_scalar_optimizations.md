### 标量优化（Scalar Optimization）
- 标量优化: 单个线程下代码的优化

#### 简介
- 分析（如数据流分析）是变换（优化）的前奏
- 5种代码低效的来源及优化（对应下面五个小节）
- 机器无关、机器相关
- 优化算法的选择和顺序很重要

#### 消除无用(useless)和不可达(unreachable)代码
- 注意: 冗余消除也会消除一些无用代码
- 消除无用代码
    - 类似标志-清除垃圾收集器
    - 后向支配性: 节点i到出口的每一天路径都经过节点j，则j后向支配i
    - 控制依赖性。j控制依赖于i，当且仅当:
        - 1. 存在一条从i到j的路径，j后向支配该路径上i之后的每个节点。即从这条边离开节点i，必经过节点j
        - 2. j不严格后向支配i
    - 反向支配边界RDF，反向控制流图中的支配边界
    - i在j的反向支配边界RDF(j)中，则j控制依赖于i
    - 消除无用代码的算法（1.找到根，初始化标志、2.标志mark、3.清除sweep）:
        - 1. 清理所有操作的标志位。找到关键（critical）操作，标志它，并加入到worklist中。关键操作: 设置返回值、输入输出语句、影响可从外部访问的地址的值。
        - 2. 遍历worklist的操作i，假设操作i为x = y op z。
        - 2.1 标志y的定义def(y)，把def(y)加入worklist
        - 2.2 标志z的定义def(z)，把def(z)加入worklist
        - 2.3 标志i所在块的后向支配边界的块的最后一个操作，并加入worklist中
        - 3. 遍历每个操作i，如果i没被标志:
        - 3.1 如果i是一个分支操作，则重写i为跳转操作，跳转到最近的包含被标志操作的后向支配节点
        - 3.2 如果i不是分支、跳转，则直接删除

- 消除无用控制流
    - 后序遍历所有块
    - 合并冗余分支指令。分支指令两个目标都指向同一个块，则变成一个跳转指令
    - 删除空程序块。程序只有一条跳转指令，则合并到其后继节点。重写其前驱的分支或跳转指令。
    - 合并程序块。i结束于跳转到j的指令，且j只有一个前驱，则把i合并到j中。从而删除跳转指令，也要重写i的前驱的分支或跳转指令。
    - 提升分支指令。i块结束于到j块（j块只有一条分支指令）的跳转指令（此时i一定不为空，j一定有多个前驱）。把j块的分支指令提升到i快。

- 消除不可达代码（块）
    - 没有路径达到该代码块（标志、清除）
    - 到达该代码块的代码路径不可能被执行(比如条件表达式为false): 需要推测分支表达式的值
    - TODO

#### 代码移动
- 缓式代码移动（lazy code motion）
    - 为了减少代码运行时间，提高运行效率
    - 代码形式不是静态单赋值，不太懂 TODO
    - 冗余、部分冗余
    - 循环不变量代码移动（loop-invariant code motion）
    - 最早放置: 表达式最早可以放置的地方。延迟放置: 表达式可以放置的地方。
    - 1. 计算可用表达式AvailIn\AvailOut和可预测表达式AntIn\AntOut
    - 2. 最早放置。计算一个表达式e求值操作最早可以放置的边，Earlist(i,j)表示该边(i,j)对应的最早表达式集合。
        - 方程式 Earlist(i,j) = AntIn(j) && ~AvailOut(i) && (ExprKill(i) U ~AntOut(i))  表示在j的起点可预测，又不能穿过i或者在i的末尾不能预测
    - 3. 延迟置放。
        - 方程式1 Later(j) = &&所有i为起点的边 Later(i, j)
        - 方程式2 Later(i, j) = Earlist(i, j) U ( LaterIn(i) && ~UEExpr(i) ),i是j的前驱
        - 所以: 一个表达式可以定义的地方区间，其上界应该是“杀死”或不可预测的节点，其下界应该是它被使用的节点。
    - 4. 重写代码
        - 方程式 Insert(i, j) = Later(i, j) && ~ LaterIn(j)  相当于插入e到可放置的下界（最晚可以定义的地方）
        - 方程式 Delete(i) = UEExpr(i) && ~ LaterIn(i)  相当于删除 在使用e又不能定义e的块中 的e
        - 如果i只有一个后继，则插入到i的末尾。
        - 如果j只有一个前驱，则插入到j的入口。
        - 如果(i, j)是一个关键边，则要插入一个程序块来拆分这条边。并将Insert(i, j)中表达式的求值放到该程序块。

- 代码提升（code hoisting）
    - 为了减少代码长度
    - 如果e属于AntOut(b)且e在b的末尾的求值，可以使各路径的求值变得冗余。则可以在b的末尾处插入对e的一个求值，删除b后各个路径对e的求值。
    - 1. AntOut(b)的每个表达式e，都插入到块b的末尾
    - 2. 对整个图进行超局部值编号，则可以删除冗余


#### 特化 Specialization （代码变换）
- 很多优化都属于特化: 常量传播、运算符强度消弱（乘号变成移位）、窥孔优化、代数恒等式、局部常量合并
- 尾调用优化
    - 尾调用: 一个调用是过程的最后一个操作
    - 正常o调用p，p调用q
    - 如果q是p的尾调用，则p可以跳转到q的一个裁剪版本。其中p只需要保存返回时需要的寄存器内容，q不需要保存寄存器内容。
    - 如果尾调用是自递归调用，则跳出递归的返回只需要一条分支指令，不是每次递归调用都使用分支指令。所以代码效率接近循环。

- 叶调用优化
    - 叶过程: 不调用其他过程的过程
    - 不需要在AR上保存自己的地址、不需要更新非局部变量的display数组、小的叶过程可以避免保存一部分寄存器
    - 叶过程可以使用静态AR、共享AR、调用者和叶过程一起分配AR

- 常数提升
    - 具有歧义的内存引用会妨碍编译器将值保持在寄存器中。特别是指针、数组引用等
    - 通过特例分析、对指针和数组下标分析，证明某个歧义值只对应一个内容地址。则可以把它放到一个标量局部变量中，进而可以放到寄存器中。
    - 可以提供两个优化版本，一个使用参数提升，一个正常编译。

#### 冗余消除
- 之前学过的冗余消除算法: 局部值编号LVN、超局部值变化SLVN、缓式代码提升LCM
    - LVN、SLVN依赖表达式的运算符和操作数编号来判断值是否相同。加上交换率、代数恒等式等优化。
    - LCM依赖名字来判断是否有相同的值。
    - 将LVN和LCM联系起来，将值的关系编码到名字空间，可以进行更好的优化。

- 基于支配者的值编号算法
    - 1. 处理块B中的选择函数，对其进行编号
    - 2. 处理块B中的赋值语句，对其进行编号
    - 3. 根据编号结果，设置其后缀节点的选择函数参数
    - 4. 对其支配者树的后缀节点，进行1-3的重复操作

#### 为其他机制提供时机
- 之前描述过的使能（enabling）变换: 循环展开、内联、树高平衡等
- 超级块复制
    - 从循环入口开始，复制每条代码路径，直到遇到反向分支。使得循环里面只有一条路径，没有分支。不过循环的数量变多了。
    - 产生更长的程序块。先复制，再局部优化，可以产生更好的代码。
    - 消除了分支，缩短了执行时间。
    - 提供了特化、冗余消除的时机
    - 缺点: 代码量变大（代码长度变大）

- 过程复制
    - 过程复制，使得常量传播等优化成为可能。

- 循环 切换/分支 外提 Loop unswitch
    - 如果循环里面的分支谓词是循环不变量，则可以把分支提出循环，循环变成了一个裁剪过的版本，分别放在各个分支上。

- 重命名
    - 静态单赋值SSA --> DVNT基于支配者的值编号 --> 重写名字，使相同的值拥有相同的名字 --> LCM缓式代码移动
    - 名字重用可能会限制指令调度。所以一般先进行指令调度，再进行寄存器分配？

#### 高级主题
- 合并优化
    - 稀疏简单常量传播SSCP、消除不可达代码
    - 稀疏条件常量传播SCCP: 在CFG上传播可达信息，在静态单赋值形式图上传播值信息。当值信息到达不动点之后，算法停止。
    - // TODO 具体内容未看

- 强度消弱
    - // TODO 具体内容未看

- 选择优化序列
    - 优化算法的选择和它们的顺序
    - 感觉很难并且不准确，书中没有介绍具体的选择和排列算法
