### 寄存器分配
- 逐出代码（spill code）: 寄存器分配器插入的load和store指令。
- IR形式: 寄存器-寄存器模型（即寄存器优先）、内存-内存模型。
- 分配: 寄存器分配将一个无限的名字空间映射到目标机的寄存器集合上。
- 指派: 寄存器指派将一个已分配的名字集合映射到目标机的物理寄存器。
- 寄存器分配很多时候都是NP完全的，指派可以在线性或者是多项式时间内完成。
- 寄存器类别: 通用寄存器、浮点数寄存器等。

#### 局部寄存器分配和指派
- 自顶向下的方法: 统计程序块引用一个值的次数（频数），由频数来确定是否为其分配物理寄存器。
    - 为每个虚拟寄存器计算一个优先级（即频数）。对程序块进行一遍遍历，记录次数。
    - 将虚拟寄存器按优先级排序。
    - 按优先级次序指派寄存器
    - 重写代码。对程序块进行一遍遍历，将虚拟寄存器替换为物理寄存器，对没分配物理寄存器的虚拟寄存器替换为load和store操作。
    - 该方法可能会浪费物理寄存器，因为不是所有虚拟寄存器的生命周期都是整个块。
- 自底向上的方法: 遍历程序块并在每个操作处决定是否需要将寄存器逐出。
    - 循环遍历每个操作 op vr1 vr2 -> vr3 
    - 确保（Ensure）每个操作的操作数vr1、vr2（虚拟寄存器）都分配了物理寄存器r1、r2
    - 释放（Free）无需再用的操作数的寄存器
    - 为操作结果vr3分配（Allocate）物理寄存器r3
    - 重写 op vr1 vr2 -> vr3 为 op v1 v2 -> v3
    - 如果r1、r2、r3需要再用，则设置它们的下次使用位置
    - 继续遍历下一个操作
- 多个块的寄存器分配
    - 计算每个块b的LiveOut(b)
    - 遍历完成一个基础块后，把LiveOut(b)中的寄存器值全部store到内存中，供后面的基础块使用
- 举例了几个问题，揭示局部寄存器分配的方法不可用于全局寄存器分配

#### 全局寄存器分配和指派
- 图着色: 相邻节点为不同颜色。使用k种颜色称为k着色。其中最小的k值，称为色数。
- 活动范围（live range）: 相关定义和使用形成的一个闭集。
- 冲突图（interference graph）: 各个活动范围之间的冲突。节点表示活动范围，边(i, j)表示LRi和LRj无法共享同一个寄存器。
- 冲突图的一个k着色方案，即寄存器指派方案。
- 全局活动范围计算:
    - 假定IR为静态单赋值格式
    - 对静态单复制的选择函数的参数和结果的集合取并集，作为一个活动范围，取同一个新的名字。
- 估算全局逐出代价
    - 地址计算、内存操作、执行频度
    - 负的逐出代价: 活动范围只有一个load和一个store，且它们引用同一个地址。负的逐出代价的活动范围都必须逐出。
    - 无限的逐出代价: 莫个活动范围和使用直接没有其他活动范围结束，则该活动范围具有无限大的逐出代价。
- 冲突
    - 冲突: 如果两个活动范围LRi和LRj，其中一个在另一个的定义处是活动的，且两者值不同，那么它们是冲突的。
    - 因为冲突的两个活动范围LRi和LRj在程序的某个操作期间都是活动的，所以它们无法驻留在同一个寄存器中
- 建立冲突图
    - 为每一个活动范围LRi创建节点Ni
    - 遍历每一个块b，设置LiveNow为LiveOut
    - 反向遍历块b中的每一个操作 OPi LRa LRb -> LRc
    - LiveNow的每一个元素LRi，添加（LRc，LRi）
    - 从LiveNow中删除LRc，添加LRa和LRb
- 活动范围拆分: 无法将活动范围保持在寄存器中，通过插入load和store操作，把大的活动范围分解成若干小的活动范围。
- 自顶向下着色
    - 按高层信息确定优先级，即着色顺序
    - 为LRi着色时，使用邻居节点没使用的颜色进行着色。如果邻居节点使用了所有颜色，则要逐出或拆分活动范围。
    - 受限的活动范围: 邻居节点大于k个
    - 先对受限的活动范围按优先级进行着色，再对不受限的活动范围进行着手。
- 自底向上着色
    - 不是使用高层信息确定着色顺序。
    - 根据冲突图的详细结构性知识来计算着色顺序。
    - 1. 使用栈来逐个保存邻居数不大于k的节点。完成后，栈中包含了所有节点。
    - 2. 逐个出栈并着色
- 活动范围有时候可以合并（一般是没有冲突的通过赋值关联的活动范围）
- 线性扫描分配: 使用区间图而不是冲突图。区间图是不精准的冲突图。

#### 高级主题
- 图着色算法的变体 TODO 未认真看
