## memory coherence
- `memory coherence`定义相同内存地址的读写操作，决定一个读操作可以返回什么值。确保多个处理器可以看到同一个内存访问顺序，但是它不确定这个内存访问顺序具体是怎样的。
  - 一般由硬件实现，软件层不用关心。
  - 一个读操作要读到当前核或者其他核的最近一个写操作
  - 同一个地址的写操作应该有序，所有处理器看到的同一个地址的写顺序要一样。
- `memory consistency`定义不同内存地址的读写操作，决定一个写操作什么时候可以被读操作看见。**定义内存访问顺序（也就是coherence遗留下来的问题）**。
  - 硬件实现一部分，并提供一些指令，由软件决定是否使用这些指令来限制内存访问顺序。
  - 具体内容详见[CPU内存排序`memory ordering`和内存屏障`barrier`](/hardware/memory_order_barrier.md)


`memory coherence`实现方式分类：
- 基于目录`Directory based`：缓存共享状态信息在一个共享的`目录`中。
  - `single directory`：单个目录，目录的每一项主要有下面内容
    - 几个位：表示缓存行的状态
    - 一个位向量（`bit vector`）：表示拥有该缓存行的核或NUMA节点
  - `Distributed directory`：多个或多级目录
    - 一般是NUMA每个节点的内存bank有一个对应的`目录`
- 嗅探`snooping`：缓存共享状态信息在缓存行中。嗅探、监控其他执行单元的写操作，有写操作时进行相应操作。相应操作可以有下面类型
  - `write invalidation`：嗅探到写操作，则使自己本地对应的缓存行无效，从内存中重新获取缓存。比如x86使用的**MESI协议**。
  - `write update`：嗅探到写操作，则更新自己本地对应的缓存行。

